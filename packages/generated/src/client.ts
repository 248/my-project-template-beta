/**
 * Generated by orval v6.31.0 ðŸº
 * Do not edit manually.
 * Template Beta Cloudflare Supabase API
 * Next.js + OpenNext + Cloudflare Workers + Supabase ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®APIä»•æ§˜
 * OpenAPI spec version: 1.0.0
 */
import type {
  AuthCallback200,
  AuthCallbackParams,
  AuthLoginParams,
  AuthResponse,
  HealthResponse,
  LogoutResponse,
} from './models';
import { orvalFetch } from './orval-fetcher';

/**
 * ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®ç¨¼åƒçŠ¶æ³ã¨ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹ã®æŽ¥ç¶šçŠ¶æ³ã‚’ç¢ºèªã—ã¾ã™
 * @summary ã‚·ã‚¹ãƒ†ãƒ ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
 */
export type getHealthResponse = {
  data: HealthResponse;
  status: number;
};

export const getGetHealthUrl = () => {
  return `/api/health`;
};

export const getHealth = async (
  options?: RequestInit
): Promise<getHealthResponse> => {
  return orvalFetch<Promise<getHealthResponse>>(getGetHealthUrl(), {
    ...options,
    method: 'GET',
  });
};

/**
 * æŒ‡å®šã•ã‚ŒãŸãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã§OAuthèªè¨¼ã‚’é–‹å§‹ã—ã¾ã™
 * @summary OAuthèªè¨¼é–‹å§‹
 */
export type authLoginResponse = {
  data: AuthResponse;
  status: number;
};

export const getAuthLoginUrl = (params: AuthLoginParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === null) {
      normalizedParams.append(key, 'null');
    } else if (value !== undefined) {
      normalizedParams.append(key, value.toString());
    }
  });

  return `/auth/login?${normalizedParams.toString()}`;
};

export const authLogin = async (
  params: AuthLoginParams,
  options?: RequestInit
): Promise<authLoginResponse> => {
  return orvalFetch<Promise<authLoginResponse>>(getAuthLoginUrl(params), {
    ...options,
    method: 'POST',
  });
};

/**
 * OAuthèªè¨¼ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã‹ã‚‰ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’å‡¦ç†ã—ã¾ã™
 * @summary OAuthèªè¨¼ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯
 */
export type authCallbackResponse = {
  data: AuthCallback200;
  status: number;
};

export const getAuthCallbackUrl = (params: AuthCallbackParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === null) {
      normalizedParams.append(key, 'null');
    } else if (value !== undefined) {
      normalizedParams.append(key, value.toString());
    }
  });

  return `/auth/callback?${normalizedParams.toString()}`;
};

export const authCallback = async (
  params: AuthCallbackParams,
  options?: RequestInit
): Promise<authCallbackResponse> => {
  return orvalFetch<Promise<authCallbackResponse>>(getAuthCallbackUrl(params), {
    ...options,
    method: 'GET',
  });
};

/**
 * ç¾åœ¨ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’çµ‚äº†ã—ã¾ã™
 * @summary ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ
 */
export type authLogoutResponse = {
  data: LogoutResponse;
  status: number;
};

export const getAuthLogoutUrl = () => {
  return `/auth/logout`;
};

export const authLogout = async (
  options?: RequestInit
): Promise<authLogoutResponse> => {
  return orvalFetch<Promise<authLogoutResponse>>(getAuthLogoutUrl(), {
    ...options,
    method: 'POST',
  });
};
